---
title: 操作系统面试高频总结
date: 2025-01-09 11:22 +0800
last_modified_at: 2025-01-09 11:2 +0800
author: FeetingTimes
categories: ["面经", "c++"]
tags: ["c++", "面经"]
pin: true
math: true
mermaid: true
---

## 进程fork后不同进程会共享哪些资源

在 UNIX 和 Linux 系统中，当使用 `fork()` 创建一个子进程时，子进程会复制父进程的大部分资源，但在某些情况下，父子进程之间会共享特定资源。

以下是 `fork()` 后父子进程之间共享和独立的资源分类：

------

### 1. **子进程与父进程之间的资源分配**

#### **1.1 独立的资源**

- **进程 ID (PID)：**
  - 子进程有自己独立的进程 ID。
- **父子关系：**
  - 子进程的父进程 ID (`PPID`) 设置为调用 `fork()` 的父进程的进程 ID。
- **用户态栈和堆：**
  - 子进程会复制父进程的用户态栈和堆，但两者是独立的，修改一方不会影响另一方。
- **文件描述符的偏移：**
  - 文件描述符表是共享的（见下），但文件偏移量是独立的。
- **信号处理：**
  - 子进程继承父进程的信号处理配置，但两者是独立的。
- **内存：**
  - 子进程会复制父进程的内存空间（通过写时复制实现）。父子进程对各自的内存修改不会互相影响，除非显式使用共享内存。

------

### **1.2 共享的资源**

- **文件描述符：**
  - 父子进程共享文件描述符表。文件描述符的打开状态（例如文件位置、访问模式等）在父子进程之间是共享的。
  - 如果一个进程关闭文件描述符，另一个进程尝试访问该文件描述符会失败。
- **打开的文件：**
  - 打开的文件由内核对象表示，文件描述符引用这些对象，因此父子进程共享同一个打开文件的内核对象。
  - 例如，父子进程可以同时访问同一个文件，且共享文件偏移量（除非显式地设置独立的偏移量）。
- **信号量：**
  - POSIX 信号量或系统 V 信号量是共享的。
- **共享内存：**
  - 如果父进程使用 `shmget`（System V）或 `mmap`（POSIX）创建了共享内存区域，子进程可以继承并与父进程共享这些区域。
- **文件锁：**
  - 父子进程共享文件锁。
- **文件系统信息：**
  - 例如工作目录和 `umask` 值。
- **消息队列：**
  - 系统 V 消息队列或 POSIX 消息队列在父子进程之间是共享的。

------

### 2. **写时复制 (Copy-On-Write, COW)**

- 在现代操作系统中，`fork()` 并不会真正复制父进程的整个内存空间，而是通过写时复制机制共享物理内存页。
- 只有当父进程或子进程尝试修改共享内存页时，内核才会为该进程分配独立的内存页。

**示例：**

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>

int main() {
    int var = 42; // 父子进程共享，但写时复制
    pid_t pid = fork();

    if (pid == 0) {
        // 子进程
        printf("Child: var = %d\n", var);
        var = 100;
        printf("Child (after modification): var = %d\n", var);
    } else {
        // 父进程
        printf("Parent: var = %d\n", var);
        sleep(1); // 确保子进程先运行
        printf("Parent (after child modification): var = %d\n", var);
    }

    return 0;
}
```

**输出示例：**

```
Parent: var = 42
Child: var = 42
Child (after modification): var = 100
Parent (after child modification): var = 42
```

子进程对 `var` 的修改不会影响父进程，表明内存是独立的。

------

### 3. **父子进程间的独立性和共享总结表**

| **资源类型**             | **独立/共享** | **说明**                                           |
| ------------------------ | ------------- | -------------------------------------------------- |
| **PID**                  | 独立          | 子进程有独立的进程 ID。                            |
| **文件描述符表**         | 共享          | 文件描述符共享，但文件偏移量可以独立。             |
| **内存空间**             | 独立（COW）   | 写时复制后独立，只有共享内存区域是共享的。         |
| **信号处理设置**         | 独立          | 父子进程各自管理自己的信号处理。                   |
| **信号量/消息队列**      | 共享          | 系统 V 和 POSIX 信号量、消息队列是共享的。         |
| **打开文件状态**         | 共享          | 打开的文件及其锁定状态是共享的。                   |
| **当前工作目录和 umask** | 共享          | 当前工作目录和文件创建掩码由父子进程共享。         |
| **环境变量**             | 独立          | 子进程会复制父进程的环境变量，但修改不影响父进程。 |
| **文件锁**               | 共享          | 文件锁是共享的，适用于系统 V 和 POSIX 文件锁机制。 |

------

### 4. **如何避免资源共享带来的问题**

- **显式关闭文件描述符**：父子进程如果不需要共享某些文件描述符，可以在其中一方显式关闭。
- **使用 `O_CLOEXEC`**：创建文件描述符时，可以设置 `O_CLOEXEC` 标志，防止文件描述符在 `exec` 系列函数调用后继承到子进程。
- **同步访问**：对于共享资源（如共享内存或文件锁），需要使用适当的同步机制（如信号量或互斥锁）。
- **避免无意义的 `fork()`**：如果共享资源可能引发竞争问题，应考虑线程模型或其他进程间通信方式（如管道、消息队列等）。

总之，理解 `fork()` 之后的资源共享和独立特性，对于编写可靠的多进程程序至关重要。

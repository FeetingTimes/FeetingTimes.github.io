---
title: RTI-DDS
date: 2025-01-22 17:21 +0800
last_modified_at: 2025-01-22 17:21 +0800
author: FeetingTimes
categories: ["DDS", "rtidds"]
tags: ["c++", "rtidds", "dds"]
pin: true
math: true
mermaid: true
img_path: /assets/img/rti-dds/
---

## RTI DDS

### 简介

#### 系统基本构成

DDS (Data Distribution Service，数据分发服务 ) 是一种基于数据的通信中间件标准，目的是建立分布式系统的高质量的数据通信。目前广泛应用于航空航天、汽车自动驾驶以及机器人、物联网等领域。 DDS 的本质是一个数据总线，通过在提供一个共享数据空间，实现各个系统之间的通信。

![rti-dds1](rti-dds1.png)

DDS 使用发布-订阅通信模式来创建去中心化、架构独立、可扩展的异步网络。DDS的标准框架中，系统之间可以通过对一个Topic的发布和订阅进行通信。在Topic上可以指定QoS以保证服务质量。

![rti-dds2](rti-dds2.png)

DDS 首先定义了通信的基础，也就是一个共享数据空间，有如下构成：全局数据空间（Global Data Space）、域 (Domain)、主题（Topic）。

![rti-dds3](rti-dds3.png)

**Global Data Space** 

在 DDS 中， DDS 网络被称为全局数据空间（Global Data Space）。

**Domain**

代表一个通信平面，由Domain ID唯一标识，只有在同一个域内的通信实体才可以通信；如果考虑车内通信，可以只划分1个Domain，也可以按照交互规则或其他规则，定义多个Domain。

**Topic**

数据的抽象概念，由TopicName标识，关联相应的数据类型(DataType)，如果把车内所涉及的所有Topic集合在一起，这样就形成一个虚拟的全局数据空间“Global Data Space”，进一步弱化了节点的概念，所以域参与者已经不是节点的概念了。

DDS标准模型定义了基于数据的操作对象和服务质量参数，包含：发布者（Publisher）、订阅者（Subscriber）、数据读取者（DataReader）、数据写入者（DataWriter）、域参与者（Domain Participant）、服务质量（QoS）。

**Domain Participant**

代表域内通信的应用程序的本地成员身份，简单来说，就是说明同一数据域内的通信成员。

**DataWriter**

据写入者，类似缓存，把需要发布的主题数据从应用层写入到DataWriter中。

**DataReader**

数据读取者，同样可以理解为一种缓存，从订阅者得到主题数据，随之传给应用层。

**Publisher**

发布者，发布主题数据，至少与1个DataWriter关联，通过调用DataWriter的相关函数将数据发出去。

**Subscriber**

订阅者，订阅主题数据，至少与1个DataReader关联。当数据到达时，应用程序可能忙于执行其他操作或应用程序只是等待该消息时，这样就会存在两种情况，同步访问和异步通知。

**服务质量QoS**

除了能够发送和接收数据之外，还可以为Publisher、 Subscriber, 或者DataReaders、 DataWriters 指定描述数据传输质量的服务质量(QoS) .众所周知， DDS 有几个 QoS 策略来帮助确保对数据传输的精确控制.您可以为这些实体分配单独的 QoS 策略，也可以分配一组称为 QoS 配置文件的 QoS 策略。

**注意**：

一个 Publisher 可以有多个DataWriter；

一个Subscriber可以有多个 DataReader ；

DataWriter 只有一个Topic ；

DataReader 只有一个Topic；

一个 Topic 可以有许多 DataReader 和 DataWriter ；

一个Publisher可以有许多关联的Subscriber ；

一个Subscriber可以有许多关联的Publisher 。

DCPS的元模型简化图如下所示：

![rti-dds4](rti-dds4.png)

DDS在各个系统之间的通信过程如下：

- Publisher通过DataWriter写入数据到Topic；
- Subscriber获得通知；
- Subscriber通过DataReader从Topic读取数据。

为了保证实时性和性能要求，可以在Topic上面定义能够满足性能需求的QoS服务质量参数，这样订阅和通知就可以基于QoS参数确定交互的时机，进而保证实时性。

![rti-dds5](rti-dds5.png)

#### 服务发现

Discovery是在不同节点上的Connext DDS对象（DomainParticipants、DataWriters、DataReaders）发现彼此的幕后方式。每个DomainParticipant维护一个关于在同一DDS domain中所有活跃的DataWriter和DataReader的信息数据库。这个数据库使得DataWriter和DataReader的交流成为可能。要创建和更新数据库，每个应用程序遵循一个通用的发现过程。

##### Simple Discovery Protocol

###### Simple Participant Discovery

该阶段的简单发现协议由Simple Participant Discovery Protocol（SPDP）执行。在参与者发现阶段，域参与者通过发送参与者声明信息(DATA submessages or announcements)，来通知同一DDS Domain中的所有其他域参与者。详细信息包括域参与者的唯一标识码（GUID or Globally Unique ID）、传输定位器（addresses and prot numbers）、QoS。这些信息通过best-effort的通信方式定期发送。

​    当接收到远程参与者发现信息时，Connext DDS将确定本地参与者是否与远程参与者匹配。只有当两者具有相同的Domain ID和Domain Tag，才会发生匹配。

​    当删除域参与者时，将发送带有域参与者标识的GUID的participant DATA(delete)消息。

​    GUID是对一个实体的唯一引用，它由GUID prefix和Entity ID组成。默认情况下，GUID prefix是从IP地址和进程ID计算而来，Entity ID由Connext DDS设置。

​	一旦一对参与者发现了对方，他们就可以进入端点发现阶段，来发现彼此的DataWriters和DataReaders。

###### Simple Endpoint Discovery

该阶段的简单发现协议由Simple Endpoint Dsicovery Protocol(SEDP)执行。在端点发现阶段，Connext DDS匹配DataWriters和DataReaders。GUID、Qos等关于应用程序的DataWriters和DataReaders的信息，通过发送DATA信息中的publication/subsrciption声明进行交换。通常将这些DATA信息称为publication DATAs和subscription DATAs。端点发现阶段使用可靠的通信方式。

当发现远程DataWriter/DataReader时，Connext DDS将确定本地应用程序是否具有相匹配的DataReader/DataWriter。只有当两者具有相同的topic、data type和兼容的QoSPolicies，才会发生匹配。此外，如果域参与者被设置为忽略某些DataWriter/DataReader时，这些实体在匹配过程中就会被忽略。DataWriter和DataReader只有在各自的应用程序都将本地实体与匹配的远程实体连接起来时才能相互通信。

##### Discovery Implementation

发现是使用内置的DataWriters和DataReaders来实现的。也就是说，它们也是DDSDataWriter/DDSDataReader。对于每个DomainParticipant，自动创建三个内置的DataWriters和DataReaders来用于发现目的。

![rti-dds6](rti-dds6.png)

对于每个DomainParticipant，有6个自动创建用于发现目的的对象。前两个对象用于发送/接收参与者DATA消息，这些消息在参与者发现阶段用去查找远程域参与者，该阶段使用best-effort通信方式。一旦参与者意识到彼此，他们就会进入端点发现阶段，以了解彼此的DataWriters和DataReaders，该阶段使用reliable通信方式。

Discovery的实现可分为两个独立的协议：SPDP + SEDP = SDP

###### Participant Discovery

当创建域参与者时，会自动创建DataWriter和DataReader，以交换网络中participant DATA消息。这些DataWriters和DataReaders是特殊的，因为DataWriter可以发送到给定的目的地列表，无论目的地上是否有Connext DDS应用程序，并且DataReaders可以从任何源接收数据，无论该源以前是否已知。也就是说，这些特殊的DataWriters和DataReaders在能够相互交流之前，是不需要发现远程实体并进行匹配的。

当域参与者加入或离开网络时，它需要通知其他对等参与者。通过participant DATA消息通知远程参与者。此外，如果参与者的QoS被修改为需要其他参与者知道发生更改，将立即发送新的participant DATA消息。participant DATA也可用来保持参与者的活跃状态。

如果新的远程参与者在本地参与者的对等方列表中，本地参与者将把远程参与者添加到它的数据库中。一旦一个远程参与者被添加到Connext DDS数据库中，Connext DDS将跟踪该远程参与者的participant_liveliness_lease_duration。如果该参与者的participant DATA消息在participant_liveliness_lease_duration内没有收到至少一次，则远程参与者将认为是过时的，远程参与者及其所有实体将从本地参与者的数据库中删除。为了避免被其他参与者清除，每个参与者都需要定期发送一个participant DATA来刷新其活力。该发送速率由participant_liveliness_assert_period控制。

![rti-dds7](rti-dds7.png)

在节点A上的域参与者向节点B（它在节点A的对等列表中）发送“participant DATA”，无论节点B上是否有Connext DDS应用程序。

上图中，绿色短虚线是周期性的particitant DATAs。这些消息之间的时间间隔由DiscoveryConfig QoSPolicy中的participant_liveliness_assert_period控制。

除了周期性的particitant DATAs外，蓝色长虚线的“initial repeat messages”从A发送到B。这些消息在min_initial_participant_announcement_period和max_initial_participant_announcement_period之间的一个随机时间发送，发送数量由initial_participant_announcements设置。

![rti-dds8](rti-dds8.png)

上图中，如果参与者A没有在规定的活跃时间内被刷新，则它将从参与者B的数据库中删除。为了简化，图中省略了从B发往A的“participant DATA”，此外参与者A的“initial repeat messages”也被省略了。

**Refresh Mechanism**

为了确保后加入的参与者不需要等到远程参与者数据的下一次刷新后才发现远程参与者，存在一种重新发送机制。如果接收到的参与者数据来自之前从未见过的远程参与者，并且在本地参与者的对等列表中，则应用程序将把自己的参与者数据重新发送给所有对等点。这种重新发送可能会进行多次，在两者之间有一个随机的睡眠时间。

![rti-dds9](rti-dds9.png)

上图中，参与者A在其对等列表中有参与者B，参与者B在其对等列表中没有参与者A，但是DiscoveryQosPolicy.accept_unknown_peers被设置为DDS_BOOLEAN_TRUE。参与者A在B发送其initial announcement后加入系统。在B发现A后，他等待时间A，然后重新发送它的参与者信息。图中initial repeat messages被省略了。

下图中，提供了参与者发现阶段所发送的消息的总体过程，参与者A和B在它们彼此的对等列表中，A先被创建。

![rti-dds10](rti-dds10.png)

**Maintaining DataWriter Libeliness for kinds AUTOMATIC and MANUAL_BY_PARTICIPANT**

Connext DDS使用内置的DataWriter和DataReader对，也被称为inter-participant reader和inter-participant writer，来保持DataWriters（被设置为AUTOMATIC or MANUAL_BY_PARTICIPANT）的活力。

当域参与者中有任何DataWriters的Liveliness QosPolicy被设置为AUTOMATIC，inter-participant writer将以这些DataWriters的最短lease_duration为时间间隔，周期可靠的广播AUTOMATIC liveliness消息。如下图中所示：

![rti-dds11](rti-dds11.png)

当域参与者中有任何DataWriters的Liveliness QosPolicy被设置为MANUAL_BY_PARTICIPANT，Connext DDS将会定期检查它们是否调用了write()、assert_liveliness()、dispose() or unregister()。这个检查的速率是每X秒，X是所有域参与者中MANUAL_BY_PARTICIPANT DataWriters的最短lease_duration。如果其中任何DataWriters调用了这些操作，inter-participant writer将会可靠广播一个MANUAL liveliness消息。

如果调用了域参与者的assert_liveliness()操作，并且该域参与者中有任意一个MANUAL_BY_PARTICIPANT DataWriter，inter-participant writer将在X时间段内可靠广播一个MANUAL liveliness消息。如下图中所有：

![rti-dds12](rti-dds12.png)

inter-participant reader从远程inter-participant writer接收数据，并相应的断言远程域参与者端点的活动性。如果域参与者没有MANUAL_BY_PARTICIPANT or AUTOMATIC DataWriter，那么inter-participant writer不会发送liveliness消息。

###### Endpoint Discovery

端点发现阶段的目标是把远程端点添加到本地数据库中，以便用户创建的端点（应用程序的DataWriters和DataReaders）可以相互通信。

当发现新的远程域参与者并添加到参与者的数据库时，Connext DDS自动为该远程域参与者添加两个发现端点reader和两个发现端点writer到本地数据库中。并于本地发现端点writer和reader进行匹配，然后就可以在两个域参与者的发现端点writer和reader之间传输publication DATAs和subscription DATAs。

当为用户数据创建DATAReader/DATAWriter时，描述新创建对象的subscription DATA/publication DATA将从本地发现端点writer发送到本地数据库中的远程域参与者的远程发现端点reader。当删除DATAReader/DATAWriter时，同理。

除了发送subscription DATA/publication DATA外，发现端点writer还会定期检查远程发现端点reader是否是最新的。如果发现端点writer没有确认远程端点reader收到最新的DATA，发现端点writer会发送一条特殊的HB消息（F=0），来请求从远程端点reader的确认，如下图所示：

![rti-dds13](rti-dds13.png)

即使当本地用户的DATAWriter和DATAReader在远程域参与者被发现前已经创建，远程参与者仍然可以被告知之前创建的DATAWriter和DATAReader。通过HB和ACK/NACK实现，当发现一个新的远程参与者时，它们分别由built-int endpoint writer和built-int endpoint reader发送。

下图中，通过HB来触发后加入者发现DataWriter。参与者A的writer C在发现参与者B之前被创建。对于A，响应接收到participant B DATA消息，participant A DATA消息被发送给B。在A上的端点发现reader也会发送ACK/NACK给B上的端点发现writer。

![rti-dds14](rti-dds14.png)

下图中，通过ACKNACK来触发后加入者发现DataWriter。参与者A的writer C在发现参与者B之前被创建。当B接收到新的Participant A DATA消息时，发送Participant B DATA给A。B上的发现端点writer也会给A上的发现端点reader发送HB消息。为了简化，这些过程在下图中被省略了。

![rti-dds15](rti-dds15.png)

### 通信报文

#### RTPS协议

RTPS层包含header(红色)和submessages(绿色)。

![rti-dds16](rti-dds16.png)

Default port mapping:不是header本身的一部分，而是从数据包的目的端口提取的信息。通过了解目的端口，可以找到domain_id, participant_index, 和the nature of the traffic(unicast or multicast, user traffic or meta traffic)。

##### RTPS Header

![rti-dds17](rti-dds17.png)

![rti-dds18](rti-dds18.png)

| Magic            | 表示该报文类型为RTPS                                     |
| ---------------- | -------------------------------------------------------- |
| Protocol version | 表示该版本号为2.3；由主版本和次版本组成                  |
| vendorId         | 表示供应商为Connext DDS                                  |
| guidPrefix       | 由host ID，app ID，instance ID组成，唯一标识该RTPS参与者 |

##### RTPS Submessages

Submessages包含flags。flags的含义取决于submessage，通常是”endianness”flag。

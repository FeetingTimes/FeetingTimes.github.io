---
title: hot100链表题解
date: 2025-01-16 15:21 +0800
last_modified_at: 2025-01-16 15:21 +0800
author: FeetingTimes
categories: ["leetcode", "hot100"]
tags: ["C++", "leetcode", "链表"]
pin: true
math: true
mermaid: true
---

## 160. 相交链表

### 问题描述

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。

图示两个链表在节点 `c1` 开始相交**：**

[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

题目数据 **保证** 整个链式结构中不存在环。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

**自定义评测：**

**评测系统** 的输入如下（你设计的程序 **不适用** 此输入）：

- `intersectVal` - 相交的起始节点的值。如果不存在相交节点，这一值为 `0`
- `listA` - 第一个链表
- `listB` - 第二个链表
- `skipA` - 在 `listA` 中（从头节点开始）跳到交叉节点的节点数
- `skipB` - 在 `listB` 中（从头节点开始）跳到交叉节点的节点数

评测系统将根据这些输入创建链式数据结构，并将两个头节点 `headA` 和 `headB` 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 **视作正确答案** 。

**示例 1：**

[![img](https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。
```

 

**示例 2：**

[![img](https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png)

```
输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Intersected at '2'
解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。
在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
```

**示例 3：**

[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png)

```
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：No intersection
解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
这两个链表不相交，因此返回 null 。
```

**提示：**

- `listA` 中节点数目为 `m`
- `listB` 中节点数目为 `n`
- $1 <= m, n <= 3 * 10^4$
- $1 <= Node.val <= 10^5$
- `0 <= skipA <= m`
- `0 <= skipB <= n`
- 如果 `listA` 和 `listB` 没有交点，`intersectVal` 为 `0`
- 如果 `listA` 和 `listB` 有交点，`intersectVal == listA[skipA] == listB[skipB]`

**进阶：**你能否设计一个时间复杂度 `O(m + n)` 、仅用 `O(1)` 内存的解决方案？

### 题解

这是一个经典的链表问题，要求找到两个链表的第一个相交节点，或者返回 `nullptr` 如果它们不相交。我们可以通过双指针法实现，时间复杂度为 $O(m + n)$，空间复杂度为 $O(1)$。

下面是详细的 C++ 代码解法：

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(nullptr) {}
 * };
 */

class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if (!headA || !headB) return nullptr; // 如果任意链表为空，直接返回 null

        ListNode *p1 = headA;
        ListNode *p2 = headB;

        // 两个指针分别遍历链表A和链表B，当到达链表末尾时跳转到另一个链表的头部
        while (p1 != p2) {
            p1 = (p1 == nullptr) ? headB : p1->next;
            p2 = (p2 == nullptr) ? headA : p2->next;
        }

        // 当两个指针相遇时，要么是交点，要么是 null（无交点）
        return p1;
    }
};
```

#### 解题思路：

1. **双指针法**：
   - 用两个指针 `p1` 和 `p2` 分别遍历链表 A 和 B。
   - 如果 `p1` 到达链表 A 的末尾，则跳转到链表 B 的头部；如果 `p2` 到达链表 B 的末尾，则跳转到链表 A 的头部。
   - 最终，两个指针会在第一个相交节点相遇，或者同时到达链表末尾（`nullptr`）。
2. **核心原理**：
   - 两个指针会遍历相同的节点数（$m + n$）。
   - 如果存在相交节点，它们会在交点相遇。
   - 如果没有交点，两个指针最终都会到达 `nullptr`。
3. **时间复杂度**：
   - 每个链表最多遍历两次，因此时间复杂度为 $O(m + n)$。
4. **空间复杂度**：
   - 仅使用了两个额外指针，空间复杂度为 $O(1)$。

#### 示例运行：

##### 示例 1：

输入：

```cpp
headA = [4,1,8,4,5]
headB = [5,6,1,8,4,5]
skipA = 2, skipB = 3
```

输出：

```cpp
Intersected at '8'
```

##### 示例 2：

输入：

```cpp
headA = [1,9,1,2,4]
headB = [3,2,4]
skipA = 3, skipB = 1
```

输出：

```cpp
Intersected at '2'
```

##### 示例 3：

输入：

```cpp
headA = [2,6,4]
headB = [1,5]
```

输出：

```cpp
No intersection
```

## 206. 反转链表

### 问题描述

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)

```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)

```
输入：head = [1,2]
输出：[2,1]
```

**示例 3：**

```
输入：head = []
输出：[]
```

**提示：**

- 链表中节点的数目范围是 `[0, 5000]`
- `-5000 <= Node.val <= 5000`

**进阶：**链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？

### 题解

以下是解决 **反转链表** 的两种方法：**迭代法** 和 **递归法**。两种方法都有效，具体实现如下：

------

#### 方法 1：迭代法

使用三个指针 (`prev`, `current`, `next`) 来完成链表反转。

##### C++ 实现：

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(nullptr) {}
 * };
 */

class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* prev = nullptr; // 用于指向前一个节点
        ListNode* current = head; // 当前节点

        while (current != nullptr) {
            ListNode* next = current->next; // 保存下一个节点
            current->next = prev; // 反转当前节点指针
            prev = current; // 前移 prev
            current = next; // 前移 current
        }

        return prev; // 最终 prev 指向反转后的链表头部
    }
};
```

##### 思路解析：

1. 用 `prev` 初始化为 `nullptr`，用于反转链表的前指针。
2. 遍历链表，通过 `current` 节点进行操作。
3. 反转当前节点指针，指向前一个节点。
4. 更新指针 `prev` 和 `current`，直到链表结束。
5. 返回 `prev`，即反转后的链表头。

------

#### 方法 2：递归法

利用递归的特性，反转链表。

##### C++ 实现：

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (head == nullptr || head->next == nullptr) {
            return head; // 如果链表为空或只有一个节点，直接返回头节点
        }

        // 递归反转后面的部分
        ListNode* reversedHead = reverseList(head->next);

        // 反转当前节点
        head->next->next = head; // 下一个节点指向当前节点
        head->next = nullptr; // 当前节点指向空

        return reversedHead; // 返回反转后的头节点
    }
};
```

##### 思路解析：

1. 递归的终止条件是 `head` 为 `nullptr` 或只有一个节点。
2. 递归反转后续节点后，利用链表结构完成反转。
3. 让 `head->next->next` 指向 `head`，同时将 `head->next` 置为 `nullptr`，从而断开原链表结构。
4. 最终返回新的头节点。

------

#### 时间与空间复杂度：

| 方法   | 时间复杂度 | 空间复杂度 |
| ------ | ---------- | ---------- |
| 迭代法 | $O(n)$     | $O(1)$     |
| 递归法 | $O(n)$     | $O(n)$     |

------

#### 示例运行：

##### 示例 1：

输入：

```cpp
head = [1, 2, 3, 4, 5]
```

输出：

```cpp
[5, 4, 3, 2, 1]
```

##### 示例 2：

输入：

```cpp
head = [1, 2]
```

输出：

```cpp
[2, 1]
```

##### 示例 3：

输入：

```cpp
head = []
```

输出：

```cpp
[]
```

## 234. 回文链表

### 问题描述

给你一个单链表的头节点 `head` ，请你判断该链表是否为 回文链表 。如果是，返回 `true` ；否则，返回 `false` 。

**示例 1：**

```
输入：head = [1,2,2,1]
输出：true
```

**示例 2：**

```
输入：head = [1,2]
输出：false
```

**提示：**

- 链表中节点数目在范围`[1, 105]` 内
- `0 <= Node.val <= 9`

**进阶：**你能否用 `O(n)` 时间复杂度和 `O(1)` 空间复杂度解决此题？

### 题解

以下是用 C++ 实现判断链表是否为回文链表的两种方法：

------

#### 方法一：辅助数组 (时间复杂度 O(n)，空间复杂度 O(n))

我们可以通过遍历链表，将节点的值存储到数组中，然后检查数组是否是回文。

##### 实现代码：

```cpp
#include <vector>
using namespace std;

struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

bool isPalindrome(ListNode* head) {
    vector<int> values;
    ListNode* current = head;

    // 将链表的值存储到数组中
    while (current) {
        values.push_back(current->val);
        current = current->next;
    }

    // 使用双指针检查数组是否为回文
    int left = 0, right = values.size() - 1;
    while (left < right) {
        if (values[left] != values[right]) {
            return false;
        }
        ++left;
        --right;
    }

    return true;
}
```

------

#### 方法二：快慢指针 + 翻转链表 (时间复杂度 O(n)，空间复杂度 O(1))

使用快慢指针找到链表中间节点，然后翻转链表后半部分，再进行比较。

##### 实现代码：

```cpp
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

ListNode* reverseList(ListNode* head) {
    ListNode* prev = nullptr;
    while (head) {
        ListNode* nextTemp = head->next;
        head->next = prev;
        prev = head;
        head = nextTemp;
    }
    return prev;
}

bool isPalindrome(ListNode* head) {
    if (!head || !head->next) {
        return true;
    }

    // 使用快慢指针找到中间节点
    ListNode *slow = head, *fast = head;
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
    }

    // 翻转后半部分链表
    ListNode* secondHalf = reverseList(slow);

    // 比较前半部分和后半部分
    ListNode* firstHalf = head;
    ListNode* secondHalfCopy = secondHalf; // 用于后续恢复链表
    while (secondHalf) {
        if (firstHalf->val != secondHalf->val) {
            return false;
        }
        firstHalf = firstHalf->next;
        secondHalf = secondHalf->next;
    }

    // 恢复链表（可选）
    reverseList(secondHalfCopy);

    return true;
}
```

------

#### 方法二的说明：

1. **找到中间节点：** 使用快慢指针，快指针移动两步，慢指针移动一步。当快指针到达末尾时，慢指针正好位于链表中间。
2. **翻转链表：** 从中间节点开始翻转链表后半部分。
3. **比较两部分：** 使用两个指针分别从链表的头部和翻转后的部分逐一比较节点值。
4. **恢复链表（可选）：** 为了不改变链表结构，可以在最后恢复链表。

------

#### 复杂度分析：

- **时间复杂度：** O(n)，找到中间节点、翻转链表和比较节点各需要 O(n) 时间。
- **空间复杂度：** O(1)，因为我们在原地操作链表。

使用方法二可以满足题目要求，同时优化了空间复杂度。

## 141. 环形链表

### 问题描述

给你一个链表的头节点 `head` ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意：`pos` 不作为参数进行传递** 。仅仅是为了标识链表的实际情况。

*如果链表中存在环* ，则返回 `true` 。 否则，返回 `false` 。

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)

```
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
```

**示例 3：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)

```
输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
```

**提示：**

- 链表中节点的数目范围是 [0, $10^4$]
- -10^5 <= Node.val <= 10^5
- `pos` 为 `-1` 或者链表中的一个 **有效索引** 。

**进阶：**你能用 `O(1)`（即，常量）内存解决此问题吗？

### 题解

用 C++ 实现判断链表是否有环，可以用以下两种方法：

------

#### 方法一：哈希表 (时间复杂度 O(n)，空间复杂度 O(n))

用一个哈希表记录访问过的节点，如果某个节点重复出现，则说明链表中存在环。

##### 实现代码：

```cpp
#include <unordered_set>
using namespace std;

struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

bool hasCycle(ListNode* head) {
    unordered_set<ListNode*> visited;
    ListNode* current = head;

    while (current) {
        if (visited.count(current)) {
            return true;
        }
        visited.insert(current);
        current = current->next;
    }

    return false;
}
```

------

#### 方法二：快慢指针 (时间复杂度 O(n)，空间复杂度 O(1))

使用两个指针，一个快指针 `fast` 和一个慢指针 `slow`。快指针每次移动两步，慢指针每次移动一步。如果链表中有环，两个指针必然会相遇。

##### 实现代码：

```cpp
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

bool hasCycle(ListNode* head) {
    if (!head || !head->next) {
        return false;
    }

    ListNode* slow = head;
    ListNode* fast = head;

    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;

        // 如果快慢指针相遇，则有环
        if (slow == fast) {
            return true;
        }
    }

    return false;
}
```

------

##### 方法二的解释：

1. 初始化指针：
   - 快指针 `fast` 和慢指针 `slow` 都从链表头部开始。
2. 快慢指针移动：
   - 快指针每次移动两步，慢指针每次移动一步。
3. 判断是否相遇：
   - 如果链表中有环，快指针会在环中追上慢指针。
   - 如果链表中没有环，快指针会在到达链表末尾时变为 `nullptr`。

------

#### 复杂度分析：

1. 时间复杂度：

    O(n)

   - 快慢指针最多遍历链表中的每个节点一次。

2. 空间复杂度：

   - 方法一使用哈希表，需要 O(n) 空间。
   - 方法二使用常量额外空间，空间复杂度为 O(1)。

------

#### 推荐：

如果要求常量空间复杂度，建议使用**方法二**（快慢指针）。它更高效，且满足题目进阶要求。

## 142. 环形链表 II

### 问题描述

给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。*

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

**不允许修改** 链表。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)

```
输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。
```

**示例 3：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)

```
输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。
```

**提示：**

- 链表中节点的数目范围在范围 $[0, 10^4]$ 内
- $-10^5 <= Node.val <= 10^5$
- `pos` 的值为 `-1` 或者链表中的一个有效索引

**进阶：**你是否可以使用 `O(1)` 空间解决此题？

### 题解

这道题可以用**Floyd 判圈算法（快慢指针）**来解决，满足题目要求的 $O(1)$ 空间复杂度。以下是具体思路和代码实现：

------

#### 解题思路

1. **判断是否存在环：**
   - 使用快慢指针：
     - 快指针每次走两步。
     - 慢指针每次走一步。
   - 如果链表中存在环，快慢指针一定会在环中相遇。
   - 如果链表没有环，快指针会率先到达链表末尾。
2. **找到环的起点：**
   - 假设从链表头到环起点的距离为 $a$，环起点到相遇点的距离为 $b$，环的长度为 $L$。
   - 当快慢指针相遇时，快指针走的总步数是慢指针的两倍，且有： $2 \times (a + b) = a + b + n \times L$ 化简得：$a = n \times L - b$ 说明从链表头到环起点的距离 $a$ 等于从相遇点沿环走 $n \times L - b$ 的距离。
   - 因此，当两个指针分别从链表头和相遇点出发，每次走一步，它们会在环的起点相遇。

------

#### C++ 代码实现

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        if (!head || !head->next) return nullptr;

        ListNode *slow = head;
        ListNode *fast = head;

        // 判断是否有环
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;

            if (slow == fast) { // 快慢指针相遇
                // 找到环的起点
                ListNode *entry = head;
                while (entry != slow) {
                    entry = entry->next;
                    slow = slow->next;
                }
                return entry; // 返回环的起点
            }
        }

        return nullptr; // 没有环
    }
};
```

------

#### 示例讲解

##### 示例 1

输入：`head = [3,2,0,-4], pos = 1`
 输出：返回索引为 1 的节点。

1. 快慢指针相遇在值为 `-4` 的节点。
2. 从头节点和相遇点分别出发，最终在值为 `2` 的节点相遇。

##### 示例 2

输入：`head = [1,2], pos = 0`
 输出：返回索引为 0 的节点。

1. 快慢指针相遇在值为 `2` 的节点。
2. 从头节点和相遇点分别出发，最终在值为 `1` 的节点相遇。

##### 示例 3

输入：`head = [1], pos = -1`
 输出：返回 `null`。

1. 快指针直接到达链表末尾，无环存在。

------

#### 时间和空间复杂度分析

- 时间复杂度：

  $O(n)$

  - 快慢指针最多遍历链表两次。

- 空间复杂度：

  $O(1)$

  - 只使用了两个指针变量。

这段代码满足题目的进阶要求，效率高且实现简洁。

## 21. 合并两个有序链表

### 问题描述

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**示例 2：**

```
输入：l1 = [], l2 = []
输出：[]
```

**示例 3：**

```
输入：l1 = [], l2 = [0]
输出：[0]
```

**提示：**

- 两个链表的节点数目范围是 `[0, 50]`
- `-100 <= Node.val <= 100`
- `l1` 和 `l2` 均按 **非递减顺序** 排列

### 题解

#### 解题思路

要将两个升序链表合并为一个新的升序链表，我们可以采用两种方法：**迭代法**和**递归法**。以下是详细的实现和代码示例。

------

#### 方法 1：迭代法

1. 创建一个哨兵节点 `dummy` 和一个当前指针 `current`，用于构建新链表。
2. 遍历两个链表，比较当前节点的值，将较小值的节点连接到 `current` 后面，并移动指针。
3. 当其中一个链表遍历完毕时，将另一个链表剩余部分直接连接到 `current`。
4. 返回哨兵节点的下一个节点 `dummy->next` 作为结果。

##### C++ 实现

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */

class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode dummy; // 哨兵节点
        ListNode* current = &dummy; // 当前指针

        // 遍历两个链表
        while (l1 && l2) {
            if (l1->val <= l2->val) {
                current->next = l1;
                l1 = l1->next;
            } else {
                current->next = l2;
                l2 = l2->next;
            }
            current = current->next;
        }

        // 连接剩余部分
        current->next = l1 ? l1 : l2;

        return dummy.next;
    }
};
```

------

#### 方法 2：递归法

1. 比较两个链表的头节点，将较小值的节点作为结果链表的当前节点。
2. 递归地处理剩余部分，连接到当前节点的 `next`。
3. 当某一个链表为空时，返回另一个链表作为剩余部分。

##### C++ 实现

```cpp
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        // 递归终止条件
        if (!l1) return l2;
        if (!l2) return l1;

        if (l1->val <= l2->val) {
            l1->next = mergeTwoLists(l1->next, l2);
            return l1;
        } else {
            l2->next = mergeTwoLists(l1, l2->next);
            return l2;
        }
    }
};
```

------

#### 示例讲解

##### 示例 1

输入：`l1 = [1,2,4], l2 = [1,3,4]`
 输出：`[1,1,2,3,4,4]`

- 比较头节点：1 <= 1，取 `1`。
- 递归合并剩余部分，依次选择：1 → 2 → 3 → 4 → 4。

##### 示例 2

输入：`l1 = [], l2 = []`
 输出：`[]`

- 两个链表为空，直接返回空。

##### 示例 3

输入：`l1 = [], l2 = [0]`
 输出：`[0]`

- 一个链表为空，返回另一个链表。

------

#### 时间和空间复杂度

##### 方法 1：迭代法

- **时间复杂度：** $O(m + n)$，其中 $m$ 和 $n$ 是两个链表的长度。
- **空间复杂度：** $O(1)$，只使用了常量额外空间。

##### 方法 2：递归法

- **时间复杂度：** $O(m + n)$。
- **空间复杂度：** $O(m + n)$，递归调用栈的深度为 $m + n$。

两种方法中，**迭代法**更高效且推荐使用，因为它的空间复杂度更低。

## 2. 两数相加

### 问题描述

给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg)

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

**示例 2：**

```
输入：l1 = [0], l2 = [0]
输出：[0]
```

**示例 3：**

```
输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]
```

**提示：**

- 每个链表中的节点数在范围 `[1, 100]` 内
- `0 <= Node.val <= 9`
- 题目数据保证列表表示的数字不含前导零

### 题解

#### 解题思路

这道题的核心是模拟**两个数字按位相加**的过程，关键在于处理以下几点：

1. **逐位相加：** 从两个链表的头节点开始相加，同时处理进位。
2. **进位处理：** 每次相加都需要记录是否有进位（大于 9 时）。
3. **处理剩余节点：** 当一个链表比另一个链表长时，需要继续处理剩余节点。
4. **处理最终进位：** 如果遍历完成后还有进位，需要额外添加一个节点。

------

#### C++ 代码实现

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode dummy; // 哨兵节点
        ListNode* current = &dummy; // 当前节点指针
        int carry = 0; // 进位

        // 遍历两个链表
        while (l1 || l2 || carry) {
            int sum = carry; // 初始值为进位
            if (l1) {
                sum += l1->val;
                l1 = l1->next;
            }
            if (l2) {
                sum += l2->val;
                l2 = l2->next;
            }

            carry = sum / 10; // 更新进位
            current->next = new ListNode(sum % 10); // 创建新节点
            current = current->next; // 移动当前指针
        }

        return dummy.next; // 返回结果链表
    }
};
```

------

#### 示例讲解

##### 示例 1

输入：`l1 = [2,4,3], l2 = [5,6,4]`
 输出：`[7,0,8]`

- 第 1 位：2 + 5 = 7，无进位。
- 第 2 位：4 + 6 = 10，结果为 0，进位为 1。
- 第 3 位：3 + 4 + 1 = 8，无进位。

##### 示例 2

输入：`l1 = [0], l2 = [0]`
 输出：`[0]`

- 只有一位，0 + 0 = 0。

##### 示例 3

输入：`l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]`
 输出：`[8,9,9,9,0,0,0,1]`

- 第 1 位：9 + 9 = 18，结果为 8，进位为 1。
- 第 2 位：9 + 9 + 1 = 19，结果为 9，进位为 1。
- 第 3 位：9 + 9 + 1 = 19，结果为 9，进位为 1。
- 第 4 位：9 + 9 + 1 = 19，结果为 9，进位为 1。
- 第 5 位：9 + 0 + 1 = 10，结果为 0，进位为 1。
- 第 6 位：9 + 0 + 1 = 10，结果为 0，进位为 1。
- 第 7 位：9 + 0 + 1 = 10，结果为 0，进位为 1。
- 第 8 位：进位 1，结果为 1。

------

#### 时间和空间复杂度

##### 时间复杂度

- 时间复杂度：

  $O(\max(m, n))$，其中 $m$ 和 $n$ 分别是两个链表的长度。

  - 每次只遍历一次两个链表。

##### 空间复杂度

- **空间复杂度：** $O(\max(m, n))$，由于需要存储结果链表，长度最多为 $\max(m, n) + 1$。

------

该代码逻辑清晰，效率高，能够正确处理所有边界情况。

## 19. 删除链表的倒数第 N 个结点

### 问题描述

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)

```
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```

**示例 2：**

```
输入：head = [1], n = 1
输出：[]
```

**示例 3：**

```
输入：head = [1,2], n = 1
输出：[1]
```

**提示：**

- 链表中结点的数目为 `sz`
- `1 <= sz <= 30`
- `0 <= Node.val <= 100`
- `1 <= n <= sz`

**进阶：**你能尝试使用一趟扫描实现吗？

### 题解

#### 解题思路

为了删除链表的倒数第 $n$ 个节点，有两种常见的方法：

1. **两次遍历：**
   - 第一次遍历计算链表的长度。
   - 第二次遍历找到倒数第 $n$ 个节点的前一个节点，并删除目标节点。
2. **一次遍历（双指针法）：**
   - 使用快慢指针：
     - 快指针先走 $n+1$ 步，慢指针从头开始。
     - 然后快慢指针同时移动，直到快指针到达链表末尾。
   - 此时慢指针正好指向倒数第 $n$ 个节点的前一个节点，删除即可。

------

#### 方法 1：两次遍历

##### C++ 实现

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */

class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        // 计算链表长度
        int length = 0;
        ListNode* temp = head;
        while (temp) {
            length++;
            temp = temp->next;
        }

        // 如果删除的是头节点
        if (n == length) {
            return head->next;
        }

        // 找到待删除节点的前一个节点
        temp = head;
        for (int i = 1; i < length - n; i++) {
            temp = temp->next;
        }

        // 删除目标节点
        temp->next = temp->next->next;
        return head;
    }
};
```

------

#### 方法 2：一次遍历（双指针法）

##### C++ 实现

```cpp
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode dummy(0); // 哨兵节点
        dummy.next = head;
        ListNode* fast = &dummy;
        ListNode* slow = &dummy;

        // 快指针先走 n+1 步
        for (int i = 0; i <= n; i++) {
            fast = fast->next;
        }

        // 快慢指针同时移动
        while (fast) {
            fast = fast->next;
            slow = slow->next;
        }

        // 删除目标节点
        slow->next = slow->next->next;

        return dummy.next;
    }
};
```

------

#### 示例讲解

##### 示例 1

输入：`head = [1,2,3,4,5], n = 2`
 输出：`[1,2,3,5]`

- 快指针先走 3 步（n+1=2+1n+1 = 2+1）。
- 快慢指针同时移动，快指针到达末尾时，慢指针指向值为 3 的节点。
- 删除值为 4 的节点。

##### 示例 2

输入：`head = [1], n = 1`
 输出：`[]`

- 快指针先走 2 步（越过链表）。
- 快慢指针同时移动，慢指针停留在哨兵节点。
- 删除值为 1 的节点。

##### 示例 3

输入：`head = [1,2], n = 1`
 输出：`[1]`

- 快指针先走 2 步。
- 快慢指针同时移动，慢指针指向值为 1 的节点。
- 删除值为 2 的节点。

------

#### 时间和空间复杂度

##### 方法 1：两次遍历

- **时间复杂度：** $O(L)$，其中 $L$ 是链表的长度。
- **空间复杂度：** $O(1)$。

##### 方法 2：一次遍历

- **时间复杂度：** $O(L)$，只需一次遍历。
- **空间复杂度：** $O(1)$。

**推荐方法 2（一次遍历），效率更高，代码更简洁。**

## 24. 两两交换链表中的节点

### 问题描述

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)

```
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```

**示例 2：**

```
输入：head = []
输出：[]
```

**示例 3：**

```
输入：head = [1]
输出：[1]
```

**提示：**

- 链表中节点的数目在范围 `[0, 100]` 内
- `0 <= Node.val <= 100`

### 题解

#### 解题思路

这道题要求两两交换链表中的相邻节点，需要注意以下几点：

1. **不能修改节点值，需调整节点指针。**
2. **递归法：** 每次交换一对节点，并递归处理剩余部分。
3. **迭代法：** 使用指针逐步遍历链表，调整每一对节点的连接。

以下是递归法和迭代法的实现。

------

#### 方法 1：递归法

1. 如果链表为空或只有一个节点，直接返回链表头。
2. 对于每一对节点，将第二个节点指向第一个节点，第一个节点指向后续递归处理的结果。
3. 返回第二个节点作为当前子链表的新头。

##### C++ 实现

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */

class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        // 终止条件：链表为空或只有一个节点
        if (!head || !head->next) {
            return head;
        }

        // 保存第二个节点
        ListNode* second = head->next;

        // 递归处理剩余部分
        head->next = swapPairs(second->next);

        // 交换当前两个节点
        second->next = head;

        // 返回新的头节点
        return second;
    }
};
```

------

#### 方法 2：迭代法

1. 使用一个哨兵节点 `dummy` 指向链表头，以便处理头节点的交换。
2. 定义指针 `prev` 指向每一对节点的前一个位置。
3. 逐步交换每一对节点：
   - 将前一个节点的 `next` 指向第二个节点。
   - 调整两个节点的指针指向。
   - 更新 `prev` 指针。
4. 返回哨兵节点的 `next` 作为结果。

##### C++ 实现

```cpp
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode dummy(0); // 哨兵节点
        dummy.next = head;
        ListNode* prev = &dummy; // 前一个节点

        while (prev->next && prev->next->next) {
            ListNode* first = prev->next;
            ListNode* second = first->next;

            // 调整指针
            first->next = second->next;
            second->next = first;
            prev->next = second;

            // 更新 prev 指针
            prev = first;
        }

        return dummy.next;
    }
};
```

------

#### 示例讲解

##### 示例 1

输入：`head = [1,2,3,4]`
 输出：`[2,1,4,3]`

- 初始链表：`1 -> 2 -> 3 -> 4`
- 交换第 1、2 节点：`2 -> 1 -> 3 -> 4`
- 交换第 3、4 节点：`2 -> 1 -> 4 -> 3`

##### 示例 2

输入：`head = []`
 输出：`[]`

- 链表为空，直接返回空。

##### 示例 3

输入：`head = [1]`
 输出：`[1]`

- 只有一个节点，无法交换。

------

#### 时间和空间复杂度

##### 方法 1：递归法

- **时间复杂度：** $O(n)$，每次递归处理两个节点。
- **空间复杂度：** $O(n)$，递归调用栈的深度为链表长度。

##### 方法 2：迭代法

- **时间复杂度：** $O(n)$，每对节点只遍历一次。
- **空间复杂度：** $O(1)$，只使用了常量额外空间。

------

#### 总结

- **递归法：** 代码简洁，适合递归思维，但存在递归调用栈的开销。
- **迭代法：** 更高效，推荐用于实际应用。

## 25. K个一组翻转链表

### 问题描述

给你链表的头节点 `head` ，每 `k` 个节点一组进行翻转，请你返回修改后的链表。

`k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg)

```
输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg)

```
输入：head = [1,2,3,4,5], k = 3
输出：[3,2,1,4,5]
```

**提示：**

- 链表中的节点数目为 `n`
- `1 <= k <= n <= 5000`
- `0 <= Node.val <= 1000`

**进阶：**你可以设计一个只用 `O(1)` 额外内存空间的算法解决此问题吗？

### 题解

#### 解题思路

这道题要求每 kk 个节点一组翻转链表，并且需要满足以下条件：

1. **局部翻转：** 每次只翻转 $k$ 个节点，剩余不足 $k$ 的部分保持原样。
2. **指针操作：** 不能修改节点值，需要通过调整节点指针来实现。
3. **空间优化：** 在 $O(1)$ 额外空间内完成。

------

#### 实现步骤

1. **统计链表长度：** 通过一次遍历计算链表的总长度，判断是否需要翻转。
2. 分组翻转：
   - 使用哨兵节点 `dummy` 方便操作。
   - 逐步翻转 $k$ 个节点，翻转完成后将翻转后的子链表连接到前面。
   - 更新指针，移动到下一组。
3. **停止条件：** 剩余节点不足 $k$ 时，直接保持原顺序。

------

#### C++ 代码实现

##### 方法：迭代法

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */

class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        if (!head || k == 1) return head;

        ListNode dummy(0); // 哨兵节点
        dummy.next = head;
        ListNode* prevGroup = &dummy; // 上一组的尾节点
        ListNode* end = head;

        while (end) {
            // 找到当前组的结尾节点
            for (int i = 1; i < k && end; i++) {
                end = end->next;
            }

            if (!end) break; // 不足 k 个节点，退出循环

            // 记录下一组的起点
            ListNode* nextGroup = end->next;

            // 翻转当前组
            ListNode* prev = nullptr;
            ListNode* curr = prevGroup->next;
            while (curr != nextGroup) {
                ListNode* tmp = curr->next;
                curr->next = prev;
                prev = curr;
                curr = tmp;
            }

            // 连接前后两组
            ListNode* start = prevGroup->next; // 当前组翻转后的尾节点
            prevGroup->next = end;
            start->next = nextGroup;

            // 移动指针到下一组
            prevGroup = start;
            end = nextGroup;
        }

        return dummy.next;
    }
};
```

------

#### 示例讲解

##### 示例 1

输入：`head = [1,2,3,4,5], k = 2`
 输出：`[2,1,4,3,5]`

1. 分组：
   - 第一组：`[1,2]` → 翻转为 `[2,1]`。
   - 第二组：`[3,4]` → 翻转为 `[4,3]`。
   - 第三组：`[5]` → 保持原样。
2. 最终结果：`[2,1,4,3,5]`。

##### 示例 2

输入：`head = [1,2,3,4,5], k = 3`
 输出：`[3,2,1,4,5]`

1. 分组：
   - 第一组：`[1,2,3]` → 翻转为 `[3,2,1]`。
   - 第二组：`[4,5]` → 保持原样。
2. 最终结果：`[3,2,1,4,5]`。

##### 示例 3

输入：`head = [1], k = 1`
 输出：`[1]`

1. 只有一个节点，不需要翻转。

------

#### 时间和空间复杂度

##### 时间复杂度

- **时间复杂度：** $O(n)$，其中 $n$ 是链表的长度。每个节点最多访问两次：一次计数，一次翻转。

#### 空间复杂度

- **空间复杂度：** $O(1)$，仅使用了指针变量。

------

#### 总结

- **优点：** 使用迭代法实现了 $O(1)$ 的空间复杂度，并且通过哨兵节点简化了边界条件处理。
- **扩展：** 如果需要递归实现，可以将每次翻转的逻辑递归调用，但递归深度可能导致空间复杂度为 $O(n/k)$。

## 138. 随机链表的复制

### 问题描述

给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random` ，该指针可以指向链表中的任何节点或空节点。

构造这个链表的 **[深拷贝](https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin)**。 深拷贝应该正好由 `n` 个 **全新** 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。**复制链表中的指针都不应指向原链表中的节点** 。

例如，如果原链表中有 `X` 和 `Y` 两个节点，其中 `X.random --> Y` 。那么在复制链表中对应的两个节点 `x` 和 `y` ，同样有 `x.random --> y` 。

返回复制链表的头节点。

用一个由 `n` 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 `[val, random_index]` 表示：

- `val`：一个表示 `Node.val` 的整数。
- `random_index`：随机指针指向的节点索引（范围从 `0` 到 `n-1`）；如果不指向任何节点，则为 `null` 。

你的代码 **只** 接受原链表的头节点 `head` 作为传入参数。

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png)

```
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png)

```
输入：head = [[1,1],[2,1]]
输出：[[1,1],[2,1]]
```

**示例 3：**

**![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png)**

```
输入：head = [[3,null],[3,0],[3,null]]
输出：[[3,null],[3,0],[3,null]]
```

**提示：**

- `0 <= n <= 1000`
- $-10^4 <= Node.val <= 10^4$
- `Node.random` 为 `null` 或指向链表中的节点。

### 题解

#### 解题思路

为了复制一个带有随机指针的链表，需要实现一个 **深拷贝**，可以采用以下两种方法：

1. **哈希表辅助法：**
   - 使用一个哈希表将原链表节点和新链表节点映射起来。
   - 第一次遍历创建新节点并存储映射。
   - 第二次遍历设置新链表节点的 `next` 和 `random` 指针。
2. **原地拷贝法（优化空间复杂度）：**
   - 不使用额外空间，在原链表中插入新节点。
   - 第一次遍历创建新节点并插入原链表。
   - 第二次遍历设置 `random` 指针。
   - 第三次遍历分离新链表和原链表。

下面详细介绍两种方法。

------

#### 方法 1：哈希表辅助法

##### 实现步骤

1. 使用哈希表记录原节点和新节点的映射关系。
2. 遍历链表创建新节点，并存入哈希表。
3. 再次遍历链表，使用哈希表设置新节点的 `next` 和 `random` 指针。

##### C++ 实现

```cpp
/**
 * Definition for a Node.
 * struct Node {
 *     int val;
 *     Node* next;
 *     Node* random;
 *     Node(int _val) {
 *         val = _val;
 *         next = nullptr;
 *         random = nullptr;
 *     }
 * };
 */

class Solution {
public:
    Node* copyRandomList(Node* head) {
        if (!head) return nullptr;

        // 哈希表存储原节点到新节点的映射
        unordered_map<Node*, Node*> nodeMap;

        // 第一次遍历：创建新节点并存入哈希表
        Node* curr = head;
        while (curr) {
            nodeMap[curr] = new Node(curr->val);
            curr = curr->next;
        }

        // 第二次遍历：设置新节点的 next 和 random 指针
        curr = head;
        while (curr) {
            nodeMap[curr]->next = nodeMap[curr->next];
            nodeMap[curr]->random = nodeMap[curr->random];
            curr = curr->next;
        }

        return nodeMap[head];
    }
};
```

------

#### 方法 2：原地拷贝法

##### 实现步骤

1. 在每个原节点后插入一个新节点，使链表变成交替排列。
2. 遍历链表，设置新节点的 `random` 指针。
3. 遍历链表，分离新链表和原链表。

##### C++ 实现

```cpp
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if (!head) return nullptr;

        // 第一步：在每个原节点后插入新节点
        Node* curr = head;
        while (curr) {
            Node* newNode = new Node(curr->val);
            newNode->next = curr->next;
            curr->next = newNode;
            curr = newNode->next;
        }

        // 第二步：设置新节点的 random 指针
        curr = head;
        while (curr) {
            if (curr->random) {
                curr->next->random = curr->random->next;
            }
            curr = curr->next->next;
        }

        // 第三步：分离新链表和原链表
        Node* newHead = head->next;
        curr = head;
        while (curr) {
            Node* newNode = curr->next;
            curr->next = newNode->next;
            if (newNode->next) {
                newNode->next = newNode->next->next;
            }
            curr = curr->next;
        }

        return newHead;
    }
};
```

------

#### 示例讲解

##### 示例 1

输入：`head = [[7,null],[13,0],[11,4],[10,2],[1,0]]`
 输出：`[[7,null],[13,0],[11,4],[10,2],[1,0]]`

- 哈希表法：
  - 第一次遍历：创建新节点并存储映射。
  - 第二次遍历：利用映射设置 `next` 和 `random`。
- 原地拷贝法：
  - 插入新节点：`7 -> 7' -> 13 -> 13' -> ...`
  - 设置 `random`：新节点 `random` 指向对应复制的节点。
  - 分离链表：分离新链表。

------

#### 时间和空间复杂度

##### 方法 1：哈希表辅助法

- **时间复杂度：** $O(n)$，需要两次遍历链表。
- **空间复杂度：** $O(n)$，哈希表存储节点映射。

##### 方法 2：原地拷贝法

- **时间复杂度：** $O(n)$，需要三次遍历链表。
- **空间复杂度：** $O(1)$，只使用了常量空间。

------

#### 总结

- **方法 1：** 简单直观，但需要额外空间存储映射。
- **方法 2：** 更高效，推荐在需要优化空间复杂度时使用。

## 148. 排序链表

### 问题描述

给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg)

```
输入：head = [4,2,1,3]
输出：[1,2,3,4]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg)

```
输入：head = [-1,5,3,4,0]
输出：[-1,0,3,4,5]
```

**示例 3：**

```
输入：head = []
输出：[]
```

**提示：**

- 链表中节点的数目在范围 $[0, 5 * 10^4]$ 内
- $-10^5 <= Node.val <= 10^5$

**进阶：**你可以在 `O(n log n)` 时间复杂度和常数级空间复杂度下，对链表进行排序吗？

### 题解

#### 解题思路

要对链表进行排序，可以采用以下方法：

1. **归并排序（推荐）：**
   - 归并排序的时间复杂度为 $O(n \log n)$，非常适合链表。
   - 使用快慢指针将链表分成两半，然后递归地对两部分排序，最后合并两部分。
   - 由于链表操作中插入和删除节点效率较高，归并排序是链表排序的理想选择。
2. **快速排序：**
   - 快速排序不适合链表，因为链表无法直接访问中间节点，导致分区操作效率较低。

**进阶要求：** 使用 $O(1)$ 的额外空间进行排序，归并排序仍然可以满足这个条件。

------

#### 归并排序的实现

##### 实现步骤

1. **分割链表：**
   - 使用快慢指针将链表分成两部分。
   - 快指针每次走两步，慢指针每次走一步。
   - 当快指针到达末尾时，慢指针正好在链表中间。
2. **递归排序：**
   - 对两部分链表递归排序。
3. **合并链表：**
   - 使用双指针将两个有序链表合并为一个新的有序链表。

------

#### C++ 代码实现

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */

class Solution {
public:
    ListNode* sortList(ListNode* head) {
        // 终止条件：链表为空或只有一个节点
        if (!head || !head->next) {
            return head;
        }

        // 1. 分割链表
        ListNode* mid = getMid(head);
        ListNode* left = head;
        ListNode* right = mid->next;
        mid->next = nullptr; // 分割链表

        // 2. 递归排序左右两部分
        left = sortList(left);
        right = sortList(right);

        // 3. 合并排序后的链表
        return merge(left, right);
    }

private:
    // 获取链表的中间节点
    ListNode* getMid(ListNode* head) {
        ListNode* slow = head;
        ListNode* fast = head->next;
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }

    // 合并两个有序链表
    ListNode* merge(ListNode* l1, ListNode* l2) {
        ListNode dummy; // 哨兵节点
        ListNode* curr = &dummy;

        while (l1 && l2) {
            if (l1->val <= l2->val) {
                curr->next = l1;
                l1 = l1->next;
            } else {
                curr->next = l2;
                l2 = l2->next;
            }
            curr = curr->next;
        }

        curr->next = l1 ? l1 : l2; // 连接剩余部分
        return dummy.next;
    }
};
```

------

#### 示例讲解

##### 示例 1

输入：`head = [4,2,1,3]`
 输出：`[1,2,3,4]`

- 初始链表：`4 -> 2 -> 1 -> 3`
- 分割：`[4,2]` 和 `[1,3]`
- 递归排序：
  - `[4,2]` → 分割为 `[4]` 和 `[2]` → 合并为 `[2,4]`
  - `[1,3]` → 分割为 `[1]` 和 `[3]` → 合并为 `[1,3]`
- 合并：`[2,4]` 和 `[1,3]` → `[1,2,3,4]`

------

#### 时间和空间复杂度

##### 时间复杂度

- **时间复杂度：** $O(n \log n)$，归并排序需要 $\log n$ 次分割，每次分割需要 $O(n)$ 的时间合并。

#### 空间复杂度

- **空间复杂度：** $O(1)$，使用了常量额外空间。
- **递归栈空间：** $O(\log n)$，递归调用深度为 $\log n$。

------

#### 总结

- 归并排序适合链表排序，因为其合并操作只需要指针操作。
- 在 $O(n \log n)$ 时间复杂度和 $O(1)$ 空间复杂度下，归并排序是最佳选择。

## 23. 合并K个升序链表

### 问题描述

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

**示例 1：**

```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
```

**示例 2：**

```
输入：lists = []
输出：[]
```

**示例 3：**

```
输入：lists = [[]]
输出：[] 
```

**提示：**

- `k == lists.length`
- `0 <= k <= 10^4`
- `0 <= lists[i].length <= 500`
- `-10^4 <= lists[i][j] <= 10^4`
- `lists[i]` 按 **升序** 排列
- `lists[i].length` 的总和不超过 `10^4`

### 题解

#### 解题思路

要将 $k$ 个升序链表合并为一个升序链表，可以采用以下几种方法：

1. **逐一合并（顺序合并）：**
   - 两两合并链表，最后得到一个合并后的链表。
   - 时间复杂度较高，不推荐。
2. **分治法：**
   - 使用分治思想，每次将链表数组分成两部分，递归合并。
   - 分治法可以显著降低时间复杂度，从 $O(k \times n)$ 降到 $O(n \log k)$。
3. **最小堆（优先队列）：**
   - 使用最小堆（或优先队列）存储每个链表的当前头节点。
   - 每次从堆中取最小值节点，并将其加入结果链表，同时将其后继节点加入堆。
   - 时间复杂度为 O(nlog⁡k)O(n \log k)，适合处理大量链表。

------

#### 方法 1：分治法

##### 实现步骤

1. 将链表数组分为两部分，递归合并每部分。
2. 使用两个链表的合并函数（归并思想）合并分治后的结果。

##### C++ 实现

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */

class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if (lists.empty()) return nullptr;
        return mergeKListsHelper(lists, 0, lists.size() - 1);
    }

private:
    // 分治合并链表
    ListNode* mergeKListsHelper(vector<ListNode*>& lists, int left, int right) {
        if (left == right) return lists[left]; // 只有一个链表，直接返回
        int mid = left + (right - left) / 2;
        ListNode* l1 = mergeKListsHelper(lists, left, mid);
        ListNode* l2 = mergeKListsHelper(lists, mid + 1, right);
        return mergeTwoLists(l1, l2);
    }

    // 合并两个链表
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode dummy; // 哨兵节点
        ListNode* current = &dummy;

        while (l1 && l2) {
            if (l1->val <= l2->val) {
                current->next = l1;
                l1 = l1->next;
            } else {
                current->next = l2;
                l2 = l2->next;
            }
            current = current->next;
        }

        current->next = l1 ? l1 : l2;
        return dummy.next;
    }
};
```

------

#### 方法 2：最小堆（优先队列）

##### 实现步骤

1. 将所有链表的头节点加入最小堆（根据节点值排序）。
2. 每次从堆中取出最小值节点，将其加入结果链表。
3. 如果该节点有后继节点，将后继节点加入堆。
4. 重复操作直到堆为空。

##### C++ 实现

```cpp
#include <queue>
class Solution {
public:
    struct Compare {
        bool operator()(ListNode* a, ListNode* b) {
            return a->val > b->val;
        }
    };

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        priority_queue<ListNode*, vector<ListNode*>, Compare> pq;

        // 将所有链表的头节点加入堆
        for (auto node : lists) {
            if (node) pq.push(node);
        }

        ListNode dummy; // 哨兵节点
        ListNode* current = &dummy;

        while (!pq.empty()) {
            ListNode* smallest = pq.top();
            pq.pop();
            current->next = smallest;
            current = current->next;

            if (smallest->next) {
                pq.push(smallest->next);
            }
        }

        return dummy.next;
    }
};
```

------

#### 示例讲解

##### 示例 1

输入：`lists = [[1,4,5],[1,3,4],[2,6]]`
 输出：`[1,1,2,3,4,4,5,6]`

- 使用分治法：
  - 将 `[[1,4,5],[1,3,4],[2,6]]` 分成两部分。
  - 合并 `[1,4,5]` 和 `[1,3,4]` → `[1,1,3,4,4,5]`。
  - 合并 `[1,1,3,4,4,5]` 和 `[2,6]` → `[1,1,2,3,4,4,5,6]`。
- 使用最小堆：
  - 初始堆：`[1,1,2]`。
  - 每次取最小值并加入结果链表，同时将其后继节点加入堆。

------

#### 时间和空间复杂度

##### 方法 1：分治法

- 时间复杂度：

  $O(n \log k)$，其中 $n$ 是链表总节点数，$k$ 是链表数量。

  - 每次合并两个链表需要 $O(n/k)$，总共递归 $\log k$ 层。

- **空间复杂度：** $O(\log k)$，递归调用栈的深度为 $\log k$。

##### 方法 2：最小堆

- **时间复杂度：** $O(n \log k)$，堆操作的时间复杂度为 $\log k$。
- **空间复杂度：** $O(k)$，堆中最多存储 $k$ 个节点。

------

#### 总结

- **分治法：** 简洁清晰，适合一般场景。
- **最小堆：** 对于 $k$ 很大时更高效，因为堆的操作规模与 $k$ 相关。

## 146. LRU缓存

### 问题描述

请你设计并实现一个满足 [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。

实现 `LRUCache` 类：

- `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
- `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。

函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。 

**示例：**

```
输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
```

**提示：**

- `1 <= capacity <= 3000`
- `0 <= key <= 10000`
- $0 <= value <= 10^5$
- 最多调用 $2 * 10^5$ 次 `get` 和 `put`

### 题解

要实现 **LRU 缓存**，需要满足以下条件：

1. 支持 $O(1)$ 的时间复杂度：
   - `get(key)`：从缓存中获取值。
   - `put(key, value)`：插入或更新值。
2. **维护访问顺序：** 按最近访问时间排序，淘汰最久未使用的元素。

#### 解题思路

可以使用 **哈希表 + 双向链表** 实现：

1. **哈希表：** 用于存储键值对，支持快速查找。

2. 双向链表：

    维护缓存中元素的访问顺序：

   - 最近访问的元素放在链表头部。
   - 最久未使用的元素放在链表尾部。

#### 操作实现

1. `get(key)`：
   - 如果 `key` 存在于缓存：
     - 将对应的节点移到链表头部（表示最近使用）。
     - 返回节点的值。
   - 如果 `key` 不存在，返回 `-1`。
2. `put(key, value)`：
   - 如果 `key` 已存在：
     - 更新其值。
     - 将节点移到链表头部。
   - 如果 `key` 不存在：
     - 如果缓存已满，移除链表尾部节点（最久未使用）。
     - 插入新节点到链表头部。

------

#### C++ 代码实现

```cpp
#include <unordered_map>
using namespace std;

class LRUCache {
private:
    // 双向链表节点定义
    struct Node {
        int key, value;
        Node* prev;
        Node* next;
        Node(int k, int v) : key(k), value(v), prev(nullptr), next(nullptr) {}
    };

    unordered_map<int, Node*> cache; // 哈希表：key -> Node
    Node* head;                     // 虚拟头节点
    Node* tail;                     // 虚拟尾节点
    int capacity;                   // 缓存容量
    int size;                       // 当前缓存大小

    // 移动节点到链表头部
    void moveToHead(Node* node) {
        removeNode(node); // 先从链表中移除
        addToHead(node);  // 再添加到头部
    }

    // 添加节点到链表头部
    void addToHead(Node* node) {
        node->prev = head;
        node->next = head->next;
        head->next->prev = node;
        head->next = node;
    }

    // 删除链表中的节点
    void removeNode(Node* node) {
        node->prev->next = node->next;
        node->next->prev = node->prev;
    }

    // 移除链表尾部节点
    Node* removeTail() {
        Node* node = tail->prev;
        removeNode(node);
        return node;
    }

public:
    LRUCache(int capacity) : capacity(capacity), size(0) {
        head = new Node(0, 0); // 虚拟头节点
        tail = new Node(0, 0); // 虚拟尾节点
        head->next = tail;
        tail->prev = head;
    }

    ~LRUCache() {
        Node* curr = head;
        while (curr) {
            Node* temp = curr;
            curr = curr->next;
            delete temp;
        }
    }

    int get(int key) {
        if (cache.count(key)) {
            Node* node = cache[key];
            moveToHead(node); // 最近访问，移到链表头部
            return node->value;
        }
        return -1; // 不存在
    }

    void put(int key, int value) {
        if (cache.count(key)) {
            Node* node = cache[key];
            node->value = value; // 更新值
            moveToHead(node);    // 移到链表头部
        } else {
            Node* newNode = new Node(key, value);
            cache[key] = newNode;
            addToHead(newNode); // 插入到链表头部
            size++;
            if (size > capacity) { // 缓存已满
                Node* tailNode = removeTail(); // 移除尾部节点
                cache.erase(tailNode->key);   // 从哈希表中删除
                delete tailNode;
                size--;
            }
        }
    }
};
```

------

#### 示例讲解

##### 示例 1

输入：

```text
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
```

输出：

```text
[null, null, null, 1, null, -1, null, -1, 3, 4]
```

操作解析：

1. `put(1, 1)`：缓存为 `{1=1}`。
2. `put(2, 2)`：缓存为 `{1=1, 2=2}`。
3. `get(1)`：返回 `1`，缓存变为 `{2=2, 1=1}`。
4. `put(3, 3)`：缓存满了，移除最久未使用的键 `2`，缓存为 `{1=1, 3=3}`。
5. `get(2)`：返回 `-1`。
6. `put(4, 4)`：缓存满了，移除最久未使用的键 `1`，缓存为 `{3=3, 4=4}`。
7. `get(1)`：返回 `-1`。
8. `get(3)`：返回 `3`。
9. `get(4)`：返回 `4`。

------

#### 时间和空间复杂度

##### 时间复杂度

- **`get` 和 `put`：** $O(1)$，哈希表和双向链表的操作均为常数时间。

##### 空间复杂度

- **空间复杂度：** $O(capacity)$，存储至多 $capacity$ 个缓存元素。

------

#### 总结

- **哈希表 + 双向链表** 是实现 LRU 缓存的最佳组合，既满足 $O(1)$ 的时间复杂度，又能够维护最近使用顺序。
- 对于大规模缓存，推荐使用类似的实现方式，具有高效性和可扩展性。

